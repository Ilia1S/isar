From 1a69c2684c31be34c30d0be942dda7294a05d466 Mon Sep 17 00:00:00 2001
From: Olivier Moysan <olivier.moysan@foss.st.com>
Date: Wed, 23 Nov 2022 16:20:15 +0100
Subject: [PATCH 051/117] adc: stm32mp15: split channel init into several
 routines

Split stm32_adc_chan_of_init channel initialization function into
several routines to increase readability and prepare channel
generic binding handling.

[Backport of commit 1727d46bf9b7 ("adc: stm32mp15: split channel init into several routines")]

Signed-off-by: Olivier Moysan <olivier.moysan@foss.st.com>
Reviewed-by: Patrick Delaunay <patrick.delaunay@foss.st.com>
Reviewed-by: Patrice Chotard <patrice.chotard@foss.st.com>
Change-Id: I99a03b3eaebd4ef065f948ae7686b3cb5963e45d
---
 drivers/adc/stm32-adc.c | 44 +++++++++++++++++++++++++++++++----------
 1 file changed, 34 insertions(+), 10 deletions(-)

diff --git a/drivers/adc/stm32-adc.c b/drivers/adc/stm32-adc.c
index ad8d1a32cd..1250385fbb 100644
--- a/drivers/adc/stm32-adc.c
+++ b/drivers/adc/stm32-adc.c
@@ -162,12 +162,8 @@ static int stm32_adc_channel_data(struct udevice *dev, int channel,
 	return 0;
 }
 
-static int stm32_adc_chan_of_init(struct udevice *dev)
+static int stm32_adc_get_legacy_chan_count(struct udevice *dev)
 {
-	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
-	struct stm32_adc *adc = dev_get_priv(dev);
-	u32 chans[STM32_ADC_CH_MAX];
-	unsigned int i, num_channels;
 	int ret;
 
 	/* Retrieve single ended channels listed in device tree */
@@ -176,12 +172,16 @@ static int stm32_adc_chan_of_init(struct udevice *dev)
 		dev_err(dev, "can't get st,adc-channels: %d\n", ret);
 		return ret;
 	}
-	num_channels = ret / sizeof(u32);
 
-	if (num_channels > adc->cfg->max_channels) {
-		dev_err(dev, "too many st,adc-channels: %d\n", num_channels);
-		return -EINVAL;
-	}
+	return (ret / sizeof(u32));
+}
+
+static int stm32_adc_legacy_chan_init(struct udevice *dev, unsigned int num_channels)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 chans[STM32_ADC_CH_MAX];
+	int i, ret;
 
 	ret = dev_read_u32_array(dev, "st,adc-channels", chans, num_channels);
 	if (ret < 0) {
@@ -197,6 +197,30 @@ static int stm32_adc_chan_of_init(struct udevice *dev)
 		uc_pdata->channel_mask |= 1 << chans[i];
 	}
 
+	return ret;
+}
+
+static int stm32_adc_chan_of_init(struct udevice *dev)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	unsigned int num_channels;
+	int ret;
+
+	ret = stm32_adc_get_legacy_chan_count(dev);
+	if (ret < 0)
+		return ret;
+	num_channels = ret;
+
+	if (num_channels > adc->cfg->max_channels) {
+		dev_err(dev, "too many st,adc-channels: %d\n", num_channels);
+		return -EINVAL;
+	}
+
+	ret = stm32_adc_legacy_chan_init(dev, num_channels);
+	if (ret < 0)
+		return ret;
+
 	uc_pdata->data_mask = (1 << adc->cfg->num_bits) - 1;
 	uc_pdata->data_format = ADC_DATA_FORMAT_BIN;
 	uc_pdata->data_timeout_us = 100000;
-- 
2.39.2

